:py:mod:`blackjax.smc.base`
===========================

.. py:module:: blackjax.smc.base


Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   blackjax.smc.base.SMCState
   blackjax.smc.base.SMCInfo



Functions
~~~~~~~~~

.. autoapisummary::

   blackjax.smc.base.init
   blackjax.smc.base.step



.. py:class:: SMCState



   State of the SMC sampler

   .. py:attribute:: particles
      :type: blackjax.types.PyTree

      

   .. py:attribute:: weights
      :type: jax.Array

      


.. py:class:: SMCInfo



   Additional information on the tempered SMC step.

   proposals: PyTree
       The particles that were proposed by the MCMC pass.
   ancestors: jnp.ndarray
       The index of the particles proposed by the MCMC pass that were selected
       by the resampling step.
   log_likelihood_increment: float
       The log-likelihood increment due to the current step of the SMC algorithm.


   .. py:attribute:: ancestors
      :type: jax.numpy.ndarray

      

   .. py:attribute:: log_likelihood_increment
      :type: float

      

   .. py:attribute:: update_info
      :type: NamedTuple

      


.. py:function:: init(particles: blackjax.types.PyTree)


.. py:function:: step(rng_key: blackjax.types.PRNGKey, state: SMCState, update_fn: Callable, weigh_fn: Callable, resample_fn: Callable, num_resampled: Optional[int] = None) -> Tuple[SMCState, SMCInfo]

   General SMC sampling step.

   `update_fn` here corresponds to the Markov kernel $M_{t+1}$, and `weigh_fn`
   corresponds to the potential function $G_t$. We first use `update_fn` to
   generate new particles from the current ones, weigh these particles using
   `weigh_fn` and resample them with `resample_fn`.

   The `update_fn` and `weigh_fn` functions must be batched by the called either
   using `jax.vmap` or `jax.pmap`.

   In Feynman-Kac terms, the algorithm goes roughly as follows:

   .. code::

       M_t: update_fn
       G_t: weigh_fn
       R_t: resample_fn
       idx = R_t(weights)
       x_t = x_tm1[idx]
       x_{t+1} = M_t(x_t)
       weights = G_t(x_{t+1})

   :param rng_key: Key used to generate pseudo-random numbers.
   :param state: Current state of the SMC sampler: particles and their respective
                 log-weights
   :param update_fn: Function that takes an array of keys and particles and returns
                     new particles.
   :param weigh_fn: Function that assigns a weight to the particles.
   :param resample_fn: Function that resamples the particles.
   :param num_resampled: The number of particles to resample. This can be used to implement
                         Waste-Free SMC :cite:p:`dau2020waste`, in which case we resample a number :math:`M<N`
                         of particles, and the update function is in charge of returning
                         :math:`N` samples.

   :returns: * *new_particles* -- An array that contains the new particles generated by this SMC step.
             * *info* -- An `SMCInfo` object that contains extra information about the SMC
               transition.


